.. \_loading:

# Loading resources as clips

The first step for making a video with MoviePy is to load the resources you wish to include in the final video.

In this section we present the different sorts of clips and how to load them.
For information on modifying a clip, see :ref:`modifying`. For how to put clips together see :ref:`compositing`. And for how to see/save theme, see :ref:`rendering` (we will usually save them in example, but we wont explain here).

There's a lot of different resources you can use with MoviePy, and you will load different resources with different subtypes of :py:class:`~moviepy.Clip.Clip`, and more precisely of :py:class:`~moviepy.audio.AudioClip.AudioClip` for any audio element, or :py:class:`~moviepy.video.VideoClip.VideoClip` for any visual element.

The following code summarizes the base clips that you can create with moviepy:

.. literalinclude:: /\_static/code/user_guide/loading/loading.py
:language: python

The best to understand all these clips more thoroughly is to read the full documentation for each in the :ref:`reference_manual`.

## Releasing resources by closing a clip

When you create some types of clip instances - e.g. `VideoFileClip` or `AudioFileClip` - MoviePy creates a subprocess and locks the file. In order to release these resources when you are finished you should call the `close()` method.

This is more important for more complex applications and is particularly important when running on Windows. While Python's garbage collector should eventually clean up the resources for you, closing them makes them available earlier.

However, if you close a clip too early, methods on the clip (and any clips derived from it) become unsafe.

So, the rules of thumb are:

    * Call ``close()`` on any clip that you **construct** once you have finished using it and have also finished using any clip that was derived from it.
    * Even if you close a :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip` instance, you still need to close the clips it was created from.
    * Otherwise, if you have a clip that was created by deriving it from from another clip (e.g. by calling ``with_mask()``), then generally you shouldn't close it. Closing the original clip will also close the copy.

Clips act as `context managers <https://docs.python.org/3/reference/datamodel.html#context-managers>`\_. This means you
can use them with a `with` statement, and they will automatically be closed at the end of the block, even if there is
an exception.

.. literalinclude:: /\_static/code/user_guide/loading/closing.py
:language: python

## Categories of video clips

Video clips are the building blocks of longer videos. Technically, they are clips with a `clip.get_frame(t)` method which outputs a `HxWx3` numpy array representing the frame of the clip at time `t`.

There are two main type of video clips:

- animated clips (made with :py:class:`~moviepy.video.VideoClip.VideoFileClip`, :py:class:`~moviepy.video.VideoClip.VideoClip` and :py:class:`~moviepy.video.io.ImageSequenceClip.ImageSequenceClip`), which will always have duration.
- unanimated clips (made with :py:class:`~moviepy.video.VideoClip.ImageClip`, :py:class:`~moviepy.video.VideoClip`TextClip` and :py:class:`~moviepy.video.VideoClip.ColorClip`), which show the same picture for an a-priori infinite duration.

There are also special video clips called masks, which belong to the categories above but output greyscale frames indicating which parts of another clip are visible or not.

A video clip can carry around an audio clip (:py:class:`~moviepy.audio.AudioClip.AudioClip`) in :py:attr:`~moviepy.video.VideoClip.VideoClip.audio` which is its _soundtrack_, and a mask clip in :py:attr:`~moviepy.video.VideoClip.VideoClip.mask`.

Animated clips

```

These are clips whose image will change over time, and which have a duration and a number of Frames Per Second.

VideoClip
""""""""""

:py:class:`~moviepy.video.VideoClip.VideoClip` is the base class for all the other video clips in MoviePy. If all you want is to edit video files, you will never need it. This class is practical when you want to make animations from frames that are generated by another library.
All you need is to define a function ``frame_function(t)`` which returns a `HxWx3` numpy array (of 8-bits integers) representing the frame at time ``t``.

Here is an example where we will create a pulsating red circle with graphical library `pillow <https://pypi.org/project/Pillow/>`_.

.. literalinclude:: /_static/code/user_guide/loading/VideoClip.py
    :language: python

Resulting in this.

.. image:: /_static/medias/user_guide/circle.gif
   :width: 128 px
   :align: center
   :alt: A pulsating red circle on black background.


.. note::
    Clips that are made with a ``frame_function`` do not have an explicit frame rate nor duration by default, so you must provide duration at clip creation and a frame rate (``fps``, frames per second) for :py:meth:`~moviepy.video.VideoClip.VideoClip.write_gif` and :py:meth:`~moviepy.video.VideoClip.VideoClip.write_videofile`, and more generally for any methods that requires iterating through the frames.

For more, see :py:class:`~moviepy.video.VideoClip.VideoClip`.


VideoFileClip
"""""""""""""""

A :py:class:`~moviepy.video.io.VideoFileClip.VideoFileClip` is a clip read from a video file (most formats are supported) or a GIF file. This is probably one of the most used object ! You load the video as follows:

.. literalinclude:: /_static/code/user_guide/loading/VideoFileClip.py
    :language: python

.. note::
    These clips will have an ``fps`` (frame per second) and ``duration`` attributes, which will be transmitted if you do small modifications of the clip, and will be used by default in :py:meth:`~moviepy.video.VideoClip.VideoClip.write_gif`, :py:meth:`~moviepy.video.VideoClip.VideoClip.write_videofile`, etc.

For more, see :py:class:`~moviepy.video.io.VideoFileClip.VideoFileClip`.


ImageSequenceClip
""""""""""""""""""

This :py:class:`~moviepy.video.io.ImageSequenceClip.ImageSequenceClip` is a clip made from a series of images :

.. literalinclude:: /_static/code/user_guide/loading/ImageSequenceClip.py
    :language: python

When creating an image sequence, ``sequence`` can be either a list of image names (that will be *played* in the provided order), a folder name (played in alphanumerical order), or a list of frames (Numpy arrays), obtained for instance from other clips.

.. warning::
    All the images in list/folder/frames must be of the same size, or an exception will be raised

For more, see :py:class:`~moviepy.video.io.ImageSequenceClip.ImageSequenceClip`.


DataVideoClip
""""""""""""""""""

:py:class:`~moviepy.video.io.VideoClip.DataVideoClip` is a video clip who take a list of datasets, a callback function,
and make each frame by iterating over dataset and invoking the callback function with the current data as first argument.

You will probably never use this. But if you do, think of it like a :py:class:`~moviepy.video.VideoClip.VideoClip`, where you make frames not based on time,
but based on each entry of a data list.

.. literalinclude:: /_static/code/user_guide/loading/DataVideoClip.py
    :language: python

For more, see For more, see :py:class:`~moviepy.video.io.VideoClip.DataVideoClip`.


UpdatedVideoClip
""""""""""""""""""

.. warning::
    This is really advanced usage, you will probably never need it, if you do, please go read the code.

:py:class:`~moviepy.video.io.VideoClip.UpdatedVideoClip` is a video whose frame_function requires some objects to be updated before we can compute it.

This is particularly practical in science where some algorithm needs to make some steps before a new frame can be generated, or maybe when trying to make a video based on a live exterior context.

When you use this, you pass a world object to it. A world object is an object who respect these 3 rules:

#. It has a ``clip_t`` property, indicating the current world time.
#. It has an ``update()`` method, that will update the world state and is responsible for increasing ``clip_t`` when a new frame can be drown.
#. It has a ``to_frame()`` method, that will render a frame based on world current state.

On :py:meth:`~moviepy.video.io.VideoClip.UpdatedVideoClip.get_frame` call, your :py:class:`~moviepy.video.io.VideoClip.UpdatedVideoClip` will try to update the world until ``world.clip_t`` is superior or equal to frame time, then it will call ``world.to_frame()``.

.. literalinclude:: /_static/code/user_guide/loading/UpdatedVideoClip.py
    :language: python



Unanimated clips
```

These are clips whose image will, at least before modifications, stay the same. By default they have no duration nor FPS, meaning you will need to define them before doing operations needing such information (for example, rendering).

ImageClip
""""""""""

:py:class:`~moviepy.video.VideoClip.ImageClip` is the base class for all unanimated clips, it's a video clip that always displays the same image. Along with :py:class:`~moviepy.video.io.VideoFileClip.VideoFileClip` it's one of the most used kind of clip.
You can create one as follows:

.. literalinclude:: /\_static/code/user_guide/loading/ImageClip.py
:language: python

For more, see :py:class:`~moviepy.video.VideoClip.ImageClip`.

TextClip
"""""""""""""""

A :py:class:`~moviepy.video.VideoClip.TextClip` is a clip that will turn a text string into an image clip.

:py:class:`~moviepy.video.VideoClip.TextClip` accept many parameters, letting you configure the appearance of the text, such as font and font size,
color, interlining, text alignment, etc.

The font you want to use must be an `OpenType font <https://fr.wikipedia.org/wiki/OpenType>`\_, and you will set it by passing the path to the font file.

Here are a few example of using :py:class:`~moviepy.video.VideoClip.TextClip` :

.. literalinclude:: /\_static/code/user_guide/loading/TextClip.py
:language: python

.. note::
The parameter `method` let you define if text should be written and overflow if too long (`label`) or be automatically broken over multiple lines (`caption`).

For a more detailed explanation of all the parameters, see :py:class:`~moviepy.video.VideoClip.TextClip`.

ColorClip
"""""""""""""""

A :py:class:`~moviepy.video.VideoClip.ColorClip` is a clip that will return an image of only one color. It is sometimes useful when doing compositing (see :ref:`compositing`).

.. literalinclude:: /\_static/code/user_guide/loading/ColorClip.py
:language: python

For more, see :py:class:`~moviepy.video.VideoClip.ColorClip`.

.. \_loading#masks:

Mask clips

```

Masks are a special kind of :py:class:`~moviepy.video.VideoClip.VideoClip` with the property ``is_mask`` set to ``True``. They can be attached to any other kind of :py:class:`~moviepy.video.VideoClip.VideoClip` through method :py:meth:`~moviepy.video.VideoClip.VideoClip.with_mask`.

When a clip as a mask attached to it, this mask will indicate which pixels will be visible when the clip is composed with other clips (see :ref:`compositing`). Masks are also used to define transparency when you export the clip as GIF file or as a PNG.

The fundamental difference between masks and standard clips is that standard clips output frames with 3 components (R-G-B) per pixel, comprised between 0 and 255, while a mask has just one component per pixel, between 0 and 1 (1 indicating a fully visible pixel and 0 a transparent pixel). Seen otherwise, a mask is always in greyscale.

When you create or load a clip that you will use as a mask you need to declare it. You can then attach it to a clip with the same dimensions :

.. literalinclude:: /_static/code/user_guide/loading/masks.py
    :language: python

.. note::
    In the case of video and image files, if these are not already black and white they will be converted automatically.

    Also, when you load an image with an *alpha layer*, like a PNG, MoviePy will use this layer as a mask unless you pass ``transparent=False``.


Any video clip can be turned into a mask with :py:meth:`~moviepy.video.VideoClip.VideoClip.to_mask`, and a mask can be turned to a standard RGB video clip with :py:meth:`~moviepy.video.VideoClip.VideoClip.to_RGB()`.

Masks are treated differently by many methods (because their frames are different) but at the core, they are :py:class:`~moviepy.video.VideoClip.VideoClip`, so you can do with theme everything you can do with a video clip: modify, cut, apply effects, save, etc.


Using audio elements with audio clips
--------------------------------------

In addition to :py:class:`~moviepy.video.VideoClip.VideoClip` for visual, you can use audio elements, like an audio file, using the :py:class:`~moviepy.audio.AudioClip.AudioClip` class.

Both are quite similar, except :py:class:`~moviepy.audio.AudioClip.AudioClip` method :py:meth:`~moviepy.audio.AudioClip.AudioClip.get_frame` return a numpy array of size ``Nx1`` for mono, and size ``Nx2`` for stereo.


AudioClip
~~~~~~~~~~

:py:class:`~moviepy.audio.AudioClip.AudioClip` is the base class for all audio clips. If all you want is to edit audio files, you will never need it.

All you need is to define a function ``frame_function(t)`` which returns a ``Nx1`` or ``Nx2`` numpy array representing the sound at time ``t``.

.. literalinclude:: /_static/code/user_guide/loading/AudioClip.py
    :language: python

For more, see :py:class:`~moviepy.audio.AudioClip.AudioClip`.


AudioFileClip
```

:py:class:`~moviepy.audio.io.AudioFileClip.AudioFileClip` is used to load an audio file. This is probably the only kind of audio clip you will use.

You simply pass it the file you want to load :

.. literalinclude:: /\_static/code/user_guide/loading/AudioFileClip.py
:language: python

For more, see :py:class:`~moviepy.audio.io.AudioFileClip.AudioFileClip`.

AudioArrayClip

```

:py:class:`~moviepy.audio.AudioClip.AudioArrayClip` is used to turn an array representing a sound into an audio clip. You will probably never use it, unless you need to use the result of some third library without using a temporary file.

You need to provide a numpy array representing the sound (of size ``Nx1`` for mono, ``Nx2`` for stereo), and the number of fps, indicating the speed at which the sound is supposed to be played.

.. literalinclude:: /_static/code/user_guide/loading/AudioArrayClip.py
    :language: python

For more, see :py:class:`~moviepy.audio.AudioClip.AudioArrayClip`.

.. _modifying:

Modifying clips and apply effects
===================================

Of course, once you will have loaded a :py:class:`~moviepy.Clip.Clip` the next step of action will be to modify it to be able to integrate it in your final video.

To modify a clip, there is three main courses of actions :
 * The built-in methods of :py:class:`~moviepy.video.VideoClip.VideoClip` or :py:class:`~moviepy.audio.AudioClip.AudioClip` modifying the properties of the object.
 * The already-implemented effects of MoviePy you can apply on clips, usually affecting the clip by applying filters on each frame of the clip at rendering time.
 * The transformation filters that you can apply using :py:func:`~moviepy.Clip.Clip.transform` and :py:func:`~moviepy.Clip.Clip.time_transform`.


How modifications are applied to a clip ?
-------------------------------------------------------

Clip copy during modification
```

The first thing you must know is that when modifying a clip, MoviePy **will never modify that clip directly**.
Instead it will return **a modified copy of the original** and let the original untouched. This is known as out-place instead of in-place behavior.

To illustrate:

.. literalinclude:: /\_static/code/user_guide/effects/modify_copy_example.py
:language: python

This is an important point to understand, because it is one of the most recurrent source of bug for newcomers.

Memory consumption of effect and modifications

```
When applying an effect or modification, it does not immediately apply the effect to all the frames of the clip, but only to the first frame: all the other frames will only be modified when required (that is, when you will write the whole clip to a file or when you will preview it).

It means that creating a new clip is neither time nor memory hungry, all the computation happen during the final rendering.


Time representations in MoviePy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Many methods that we will see accept duration or timepoint as arguments. For instance :py:meth:`clip.subclipped(t_start, t_end) <moviepy.Clip.Clip.subclipped(t_start, t_end)>` which cuts the clip between two timepoints.

MoviePy usually accept duration and timepoint as either:

* a number of seconds as a ``float``.
* a ``tuple`` with ``(minutes, seconds)`` or ``(hours, minutes, seconds)``.
* a ``string`` such as ``'00:03:50.54'``.

Also, you can usually provide negative times, indicating a time from the end of the clip. For example, ``clip.subclipped(-20, -10)`` cuts the clip between 20s before the end and 10s before the end.


Modify a clip using the ``with_*`` methods
-------------------------------------------------------

The first way to modify a clip is by modifying internal properties of your object, thus modifying his behavior.

These methods usually start with the prefix ``with_`` or ``without_``, indicating that they will return a copy of the clip with the properties modified.

So, you may write something like:

.. literalinclude:: /_static/code/user_guide/effects/using_with_methods.py
    :language: python

In addition to the ``with_*`` methods, a handful of very common methods are also accessible under shorter names:

- :py:meth:`~moviepy.video.VideoClip.VideoClip.resized`
- :py:meth:`~moviepy.video.VideoClip.VideoClip.crop`
- :py:meth:`~moviepy.video.VideoClip.VideoClip.rotate`

For a list of all those methods, see :py:class:`~moviepy.Clip.Clip` and :py:class:`~moviepy.video.VideoClip.VideoClip`.


.. _modifying#effects:

Modify a clip using effects
---------------------------------

The second way to modify a clip is by using effects that will modify the frames of the clip (which internally are no more than `numpy arrays <https://numpy.org>`_)  by applying some sort of functions on them.

MoviePy come with many effects implemented in :py:mod:`moviepy.video.fx` for visual effects and :py:mod:`moviepy.audio.fx` for audio effects.
For practicality, these two modules are loaded in MoviePy as ``vfx`` and ``afx``, letting you import them as ``from moviepy import vfx, afx``.

To use these effects, you simply need to instantiate them as object and apply them on your :py:class:`~moviepy.Clip.Clip` using method :py:meth:`~moviepy.Clip.Clip.with_effects`, with a list of :py:class:`~moviepy.Effect.Effect` objects you want to apply.

For convenience the effects are also dynamically added as method of :py:class:`~moviepy.video.VideoClip.VideoClip` and :py:class:`~moviepy.video.AudioClip.AudioClip`  classes at runtime, letting you call them as simple method of your clip.

So, you may write something like:

.. literalinclude:: /_static/code/user_guide/effects/using_effects.py
    :language: python

.. note::
    MoviePy effects are automatically applied to both the sound and the mask of the clip if it is relevant, so that you don't have to worry about modifying these.

For a list of those effects, see :py:mod:`moviepy.video.fx` and :py:mod:`moviepy.audio.fx`.

In addition to the effects already provided by MoviePy, you can obviously :ref:`create_effects` and use them the same way.

.. _modifying#filters:

Modify a clip appearance and timing using filters
----------------------------------------------------------

In addition to modifying a clip's properties and using effects, you can also modify the appearance or timing of a clip by using your own custom *filters* with :py:func:`~moviepy.Clip.Clip.time_transform`, :py:func:`~moviepy.Clip.Clip.image_transform`, and more generally with :py:func:`~moviepy.Clip.Clip.transform`.

All these methods work by taking as first parameter a callback function that will receive either a clip frame, a timepoint, or both, and return a modified version of these.

Modify only the timing of a Clip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can change the timeline of the clip with :py:meth:`time_transform(your_filter) <moviepy.Clip.Clip.time_transform>`.
Where ``your_filter`` is a callback function taking clip time as a parameter and returning a new time:

.. literalinclude:: /_static/code/user_guide/effects/time_transform.py
    :language: python

Now the clip ``modified_clip1`` plays three times faster than ``my_clip``, while ``modified_clip2`` will be oscillating between 00:00:00 to 00:00:02 of ``my_clip``. Note that in the last case you have created a clip of infinite duration (which is not a problem for the moment).

.. note::
    By default :py:func:`~moviepy.Clip.Clip.time_transform` will only modify the clip main frame, without modifying clip audio or mask for :py:class:`~moviepy.video.VideoClip.VideoClip`.

    If you wish to also modify audio and/or mask you can provide the parameter ``apply_to`` with either ``'audio'``, ``'mask'``, or ``['audio', 'mask']``.


Modifying only the appearance of a Clip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For :py:class:`~moviepy.video.VideoClip.VideoClip`, you can change the appearance of the clip with :py:meth:`image_transform(your_filter) <moviepy.video.VideoClip.VideoClip.image_transform>`.
Where ``your_filter`` is a callback function, taking clip frame (a numpy array) as a parameter and returning the transformed frame:

.. literalinclude:: /_static/code/user_guide/effects/image_transform.py
    :language: python

Now the clip ``modified_clip1`` will have his green and blue canals inverted.

.. note::
    You can define if transformation should be applied to audio and mask same as for :py:func:`~moviepy.Clip.Clip.time_transform`.

.. note::
    Sometimes need to treat clip frames and mask frames in a different way. To distinguish between the two, you can always look at their shape, clips are ``H*W*3``, and masks ``H*W``.


Modifying both the appearance and the timing of a Clip
```

Finally, you may want to process the clip by taking into account both the time and the frame picture, for example to apply visual effects variating with time.
This is possible with the method :py:meth:`transform(your_filter) <moviepy.Clip.Clip.transform>`.
Where `your_filter` is a callback function taking two parameters, and returning a new frame picture. Where first argument is a `get_frame` method (i.e. a function `get_frame(time)` which given a time returns the clip’s frame at that time), and the second argument is the time.

.. literalinclude:: /\_static/code/user_guide/effects/transform.py
:language: python

This will scroll down the clip, with a constant height of 360 pixels.

.. note::
You can define if transformation should be applied to audio and mask same as for :py:func:`~moviepy.Clip.Clip.time_transform`.

.. note::
When programming a new effect, whenever it is possible, prefer using `time_transform` and `image_transform` instead of `transform` when implementing new effects.
The reason is that, though they both internally rely on `transform` when these effects are applied to `ImageClip` objects, MoviePy will recognize they only need to be applied once instead of on each frame, resulting in faster renderings.

To keep things simple, we have only addressed the case of :py:class:`~moviepy.video.VideoClip.VideoClip`, but know that the same principle applies to :py:class:`~moviepy.audio.AudioClip.AudioClip`, except that instead of a picture frame, you will have an audio frame, which is also a numpy array.

.. \_create_effects:

# Creating your own effects

In addition to the existing effects already offered by MoviePy, we can create our own effects to modify a clip however we want.

## Why creating your own effects?

For simple enough tasks, we've seen that we can :ref:`modifying#filters`. Though it might be enough for simple tasks, filters are kind of limited:

- They can only access frame and/or timepoint
- We cannot pass arguments to them
- They are hard to maintain and re-use

To allow for more complex and reusable clip modifications, we can create our own custom effects, that we will later apply with :py:func:`~moviepy.Clip.Clip.with_effects`.

For example, imagine we want to add a progress bar to a clip, to do so we will not only need the time and image of the current frame, but also the total duration of the clip.
We will also probably want to be able to pass parameters to define the appearance of the progress bar, such as color or height. This is a perfect task for an effect!

## Creating an effect

In MoviePy, effects are objects of type :py:class:`moviepy.Effect.Effect`, which is the base `abstract class` for all effects (kind of the same as :py:class:`~moviepy.Clip.Clip` is the base for all :py:class:`~moviepy.video.VideoClip.VideoClip` and :py:class:`~moviepy.audio.AudioClip.AudioClip`).

So, to create an effect, we will need to inherit the :py:class:`~moviepy.Effect.Effect` class, and do two things:

- Create an `__init__` method to be able to received the parameters of our effect.
- Implement the inherited :py:meth:`~moviepy.Effect.Effect.apply` method, which must take as an argument the clip we want to modify, and return the modified version.

In the end, your effect will probably use :py:func:`~moviepy.Clip.Clip.time_transform`, :py:func:`~moviepy.Clip.Clip.image_transform`, or :py:func:`~moviepy.Clip.Clip.transform` to really apply your modifications on the clip,
The main difference is, because your filter will be a method or an anonymous function inside your effect class, you will be able to access all properties of your object from it!

So, lets see how we could create our progress bar effect:

.. literalinclude:: /\_static/code/user_guide/effects/custom_effect.py
:language: python

.. note::
When creating an effect, you frequently have to write boilerplate code for assigning properties on object initialization, `dataclasses` is a nice way to limit that.

If you want to create your own effects, in addition of this documentation we strongly encourage you to go and take a look at the existing ones (see :py:mod:`moviepy.video.fx` and :py:mod:`moviepy.audio.fx`) to see how they works and take inspiration.

.. \_compositing:

# Compositing multiple clips

Video composition, also known as non-linear editing, is the fact of mixing and playing several clips together in a new clip. This video is a good example of what compositing you can do with MoviePy:

.. raw:: html

        <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; margin-bottom:30px; height: 0; overflow: hidden; margin-left:15%;">
            <iframe type="text/html" src="https://youtube.com/embed/rIehsqqYFEM?rel=0" frameborder="0"
            style="position: absolute; top: 0; bottom: 10; width: 70%; height: 100%; "></iframe>
        </div>

.. note::
Before starting, note that video clips generally carry an audio track and a mask, which are also clips. When you compose these clips together, the soundtrack and mask of the final clip are automatically generated by putting together the soundtracks and masks of the clips.
So most of the time you don't need to worry about mixing the audio and masks.

Juxtaposing and concatenating clips

```

Two simple ways of putting clips together is to concatenate them (to play them one after the other in a single long clip) or to juxtapose them (to put them side by side in a single larger clip).

Concatenating multiple clips
"""""""""""""""""""""""""""""""""

Concatenation can be done very easily with the function :py:func:`~moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips`.

.. literalinclude:: /_static/code/user_guide/compositing/concatenate.py
    :language: python

The ``final_clip`` is a clip that plays the clips 1, 2, and 3 one after the other.

.. note::
    The clips do not need to be the same size. If they aren't, they will all appear centered in a clip large enough to contain the biggest of them, with optionally a color of your choosing to fill the background.

For more info, see :py:func:`~moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips`.


Juxtaposing multiple clips
""""""""""""""""""""""""""""""

Putting multiple clip side by side is done with :py:func:`~moviepy.video.compositing.CompositeVideoClip.clip_array`:

.. literalinclude:: /_static/code/user_guide/compositing/juxtaposing.py
    :language: python

You obtain a clip which looks like this:

.. figure:: /_static/medias/user_guide/stacked.jpeg
   :align: center

For more info, see :py:func:`~moviepy.video.compositing.CompositeVideoClip.clip_array`.


More complex video compositing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip` class is the base of all video compositing.
For example, internally, both :py:func:`~moviepy.video.compositing.CompositeVideoClip.concatenate_videoclips` and :py:func:`~moviepy.video.compositing.CompositeVideoClip.clip_array` create a :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip`.

It provides a very flexible way to compose clips, by playing multiple clip *on top of* of each other, in the order they have been passed to :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip`, here's an example :

.. literalinclude:: /_static/code/user_guide/compositing/CompositeVideoClip.py
    :language: python

Now ``final_clip`` plays all clips at the same time, with ``clip3`` over ``clip2`` over ``clip1``. It means that, if all clips have the same size, then only ``clip3``, which is on top, will be visible in the video...
Unless  ``clip3`` and/or ``clip2`` have masks which hide parts of them.

.. note::
    Note that by default the composition has the size of its first clip (as it is generally a *background*). But sometimes you will want to make your clips *float* in a bigger composition.
    To do so, just pass the size of the final composition as ``size`` parameter of :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip`.

For now we have stacked multiple clip on top of each others, but this is obviously not enough for doing real video compositing.
For that, we will need to change when some clip starts and stops playing, as well as define the x:y, position of these clips in the final video.

For more info, see :py:class:`~moviepy.video.compositing.CompositeVideoClip.CompositeVideoClip`.

Changing starting and stopping times of clips
""""""""""""""""""""""""""""""""""""""""""""""""

In a CompositionClip, each clip start to play at a time that is specified by his ``clip.start`` attribute, and will play until ``clip.end``.

So, considering that you would want to play ``clip1`` for the first 6 seconds, ``clip2`` 5 seconds after the start of the video, and finally ``clip3`` at the end of ``clip2``, you would do as follows:

.. literalinclude:: /_static/code/user_guide/compositing/with_start.py
    :language: python

.. note::
    When working with timing of your clip, you will frequently want to keep only parts of the original clip.
    To do so, you should take a look at :py:meth:`~moviepy.Clip.Clip.subclipped` and :py:meth:`~moviepy.Clip.Clip.with_section_cut_out`.


Positioning clips
""""""""""""""""""

Frequently, you will want a smaller clip to appear on top of a larger one, and decide where it will appear in the composition by setting their position.

You can do so by using the :py:meth:`~moviepy.video.VideoClip.VideoClip.with_position` method. The position is always defined from the top left corner, but you can define it
in many ways :

.. literalinclude:: /_static/code/user_guide/compositing/with_position.py
    :language: python

When indicating the position keep in mind that the ``y`` coordinate has its zero at the top of the picture:

.. figure:: /_static/medias/user_guide/videoWH.jpeg


Adding transitions effects
""""""""""""""""""""""""""

The last part of composition is adding transition effects. For example, when a clip start while another is still playing, it would be nice to make the new one fade-in instead of showing abruptly.

To do so, we can use the transitions offered by MoviePy in :py:mod:`~moviepy.video.compositing.transitions`, like :py:func:`~moviepy.video.compositing.transitions.crossfadein` :

.. literalinclude:: /_static/code/user_guide/compositing/crossfadein.py
    :language: python


MoviePy offer only few transitions in :py:mod:`~moviepy.video.compositing.transitions`. But technically, transitions are mostly effects applied to the mask of a clip!
That means you can actually use any of the already existing effects, and use them as transitions by applying them on the mask of your clip (see .

For more info, see :py:mod:`~moviepy.video.compositing.transitions` and :py:mod:`moviepy.video.fx`.


Compositing audio clips
-------------------------

When you mix video clips together, MoviePy will automatically compose their respective audio tracks to form the audio track of the final clip, so you don't need to worry about compositing these tracks yourself.

If you want to make a custom audio track from several audio sources, audio clips can be mixed together like video clips, with :py:class:`~moviepy.audio.AudioClip.CompositeAudioClip` and :py:func:`~moviepy.audio.AudioClip.concatenate_audioclips`:

.. literalinclude:: /_static/code/user_guide/compositing/CompositeAudioClip.py
    :language: python

.. _rendering:

Previewing and saving video clips
====================================

Once you are down working with your clips, the last step will be to export the result into a video/image file, or sometimes to simply preview it in order to verify everything is working as expected.

Previewing a clip
"""""""""""""""""""""

When you are working with a clip, you will frequently need to have a peak at what your clip looks like, either to verify that everything is working as intended, or to check how things looks.

To do so you could render your entire clip into a file, but that's a pretty long task, and you only need a quick look, so a better solution exists: previewing.

Preview a clip as a video
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. warning::
    You must have ``ffplay`` installed and accessible to MoviePy to be able to use :py:func:`~moviepy.video.io.preview.preview`.
    If you'r not sure, take a look :ref:`install#binaries`

The first thing you can do is to preview your clip as a video, by calling method :py:func:`~moviepy.video.io.preview.preview` on your clip:

.. literalinclude:: /_static/code/user_guide/rendering/preview.py
    :language: python

You will probably frequently want to preview only a small portion of your clip, though ``preview`` do not offer such capabilities, you can easily emulate such behavior by using :py:meth:`~moviepy.Clip.Clip.subclipped`.

.. note::
    It is quite frequent for a clip preview to be out of sync, or to play slower than it should. It means that your computer is not powerful enough to render the clip in real time.

    Don't hesitate to play with the options of preview: for instance, lower the fps of the sound (11000 Hz is still fine) and the video. Also, downsizing your video with resize can help.

For more info, see :py:func:`~moviepy.video.io.preview.preview`.

.. note::
    A quite similar function is also available for :py:func:`~moviepy.audio.AudioClip.AudioClip`, see :py:func:`~moviepy.audio.io.ffplay_audiopreviewer.ffplay_audiopreview`.


Preview just one frame of a clip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In a lot of situation, you don't really need to preview your all clip, seeing only one frame is enough to see how it looks like and to make sure everything goes as expected.

To do so, you can use the method :py:func:`~moviepy.video.io.preview.show` on your clip, passing the frame time as an argument:

.. literalinclude:: /_static/code/user_guide/rendering/show.py
    :language: python

Contrary to video previewing, show does not require ``ffplay``, but use ``pillow`` ``Image.show`` function.

For more info, see :py:func:`~moviepy.video.io.preview.show`.


Showing a clip in Jupyter Notebook
```

If you work with a `Jupyter Notebook <https://jupyter.org/>`\_, it can be very practical to display your clip the notebook. To do so, you can use the method :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook` on your clip.

.. image:: /\_static/medias/user_guide/demo_preview.jpeg
:width: 500px
:align: center

With :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook` you can embed videos, images and sounds, either from a file or directly from a clip:

.. literalinclude:: /\_static/code/user_guide/rendering/display_in_notebook.py
:language: python

.. warning::
Know that :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook` will only work if it is on the last line a the notebook cell.

    Also, note that :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook` actually embeds the clips physically in your notebook. The advantage is that you can move the notebook or put it online and the videos will work.
    The drawback is that the file size of the notebook can become very large. Depending on your browser, re-computing and displaying at video many times can take some place in the cache and the RAM (it will only be a problem for intensive uses).
    Restarting your browser solves the problem.

For more info, see :py:func:`~moviepy.video.io.display_in_notebook.display_in_notebook`.

Save your clip into a file
""""""""""""""""""""""""""""""""""""""""

Once you are satisfied with how your clip looks, you can save it into a file, a step known in video edition as rendering. MoviePy offer various way to save your clip.

Video files (.mp4, .webm, .ogv...)

```

The obvious first choice will be to write your clip to a video file, which you can do with :py:meth:`~moviepy.video.VideoClip.VideoClip.write_videofile`:

.. literalinclude:: /_static/code/user_guide/rendering/write_videofile.py
    :language: python

MoviePy can find the a default codec name for the most common file extensions. If you want to use exotic formats or if you are not happy with the defaults you can provide the codec with ``codec='mpeg4'`` for instance.

There are many many options when you are writing a video (bitrate, parameters of the audio writing, file size optimization, number of processors to use, etc.), and we will not go in details into each. So, for more info, see :py:meth:`~moviepy.video.VideoClip.VideoClip.write_videofile`.

.. note::
    Though you are encouraged to play with settings of ``write_videofile``, know that lowering the optimization preset or increasing the number of threads will not necessarily
    improve the rendering time, as the bottleneck may be on MoviePy computation of each frame and not in ffmpeg encoding.

    Also, know that it is possible to pass additional parameters to ffmpeg command line invoked by MoviePy by using the ``ffmpeg_params`` argument.

Sometimes it is impossible for MoviePy to guess the ``duration`` attribute of the clip (keep in mind that some clips, like ImageClips displaying a picture, have *a priori* an infinite duration). Then, the ``duration`` must be set manually with :py:meth:`~moviepy.Clip.Clip.with_duration`:

.. literalinclude:: /_static/code/user_guide/rendering/write_videofile_duration.py
    :language: python


.. note::
    A quite similar function is also available for :py:func:`~moviepy.audio.AudioClip.AudioClip`, see :py:func:`~moviepy.audio.io.AudioClip.write_audiofile`.


Export a single frame of the clip
```

As for previewing, sometimes you will need to export only one frame of a clip, for example to create the preview image of a video. You can do so with :py:meth:`~moviepy.video.VideoClip.VideoClip.save_frame`:

.. literalinclude:: /\_static/code/user_guide/rendering/save_frame.py
:language: python

For more info, see :py:func:`~moviepy.video.VideoClip.VideoClip.save_frame`.

Animated GIFs

```

In addition to writing video files, MoviePy also let you write GIF file with :py:meth:`~moviepy.video.VideoClip.VideoClip.write_gif`:

.. literalinclude:: /_static/code/user_guide/rendering/write_gif.py
    :language: python


For more info, see :py:func:`~moviepy.video.VideoClip.VideoClip.write_gif`.


Export all the clip as images in a directory
```

Lastly, you may wish to export an entire clip as an image sequence (multiple images in one directory, one image per frame). You can do so with the function :py:meth:`~moviepy.video.VideoClip.VideoClip.write_images_sequence`:

.. literalinclude:: /\_static/code/user_guide/rendering/write_images_sequence.py
:language: python

For more info, see :py:func:`~moviepy.video.VideoClip.VideoClip.write_images_sequence`.
